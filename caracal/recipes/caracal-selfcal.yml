#!/usr/bin/env -S stimela run --last-recipe
_include:
  - caracal-libs.yml

caracal-selfcal:
  name: CARACal selfcal recipe
  info: "Second generation calibration recipe developed for CaraCal"
 
  inputs:
    _include: caracal-schema.yml
    obs:
      info: "Selects observation by label -- edit caracal-observation-sets.yml"
      required: true
    ms:
      dtype: MS
      aliases: ['*.ms']
    selfcal._niters:
      info: Number of iteration to process
      dtype: List[int]
      default: =RANGE(-1+current.selfcal.start-iter, 2+current.selfcal.niter)

  for_loop:
    var: iter
    over: selfcal._niters
    display_status: "{var}={value} {index1}/{total}"
    scatter: 1

  steps:

    restore-flags:
      info: restore flags to a specific version
      cab: casa.flagman
      skip: true
      params:
        ms: =recipe.ms
        versionname: =step.save-flags-0.versionname
        mode: restore

    pa-correction:
      info: invokes cubical to correct for parallactic angle
      skip: IF(recipe.selfcal.enable, IF(recipe.selfcal.pa-rotate, IF(recipe.iter==0, false, true), true), true)
      skip_if_outputs: fresh
      _use: lib.steps.cubical.pa-corr
      params:
        data.ms: =recipe.ms
        out.column: 'PA_CORRECTED_DATA'
        out.dir: "{recipe.dir-out-base}/cal-pa.cc-out"
        dist.ncpu: =recipe.ncpu
        dist.min-chunks: =recipe.ncpu
        model.list: ''
        flags.apply: "-cubical0"
        flags.auto-init: legacy
        flags.save: "cubical0"
        flags.save-legacy: auto
        flags.reinit-bitflags: false
        k.save-to: "{recipe.dir-out-base}/PAsol"

    previous-image-index:
      info: prefix for image files
      cab: iter_out
      params:
        iter: =recipe.iter

    image-pol:
      info: image and construct initial model image using the PA_CORRECTED_DATA column using a mask
      skip: =IF(recipe.image-enable, false, true)
      _use: lib.steps.wsclean.image
      skip_if_outputs: fresh
      params:
        prefix: ="{recipe.dir-out-base}/image_{recipe.iter}/{recipe.image-prefix}_{recipe.iter}"
        column: =IF(recipe.iter>1, "CORRECTED_DATA", IF(recipe.selfcal.pa-rotate, steps.pa-correction.out.column, recipe.image-col))
        fits-mask: =IFSET(recipe.image-fits-mask, recipe.image-fits-mask, IFSET(recipe.image-cleanmask-method, IF(recipe.iter>0, "{recipe.dir-out-base}/image_{steps.previous-image-index.iter-out}/{recipe.image-prefix}_{steps.previous-image-index.iter-out}-MFS-mask.fits", UNSET, UNSET), UNSET))
        no-update-model-required: =IF(recipe.iter>0, IF(recipe.image-no-update-model-required, true, false), true)

    quality-assess:
      info: image quality assessment
      cab: aimfast
      skip_if_outputs: fresh
      skip: =IF(recipe.image-enable, IF(recipe.image-aimfast-enable, false, true), true)
      params:
        residual_image: =steps.image*.residual.mfs
        outfile: '{steps.image*.prefix}-im-{info.suffix}.json'

    masking:
      info: generate a mask
      cab: breizorro
      skip_if_outputs: fresh
      skip: =IF(recipe.image-enable, IF(recipe.image-cleanmask-method=="breizorro", false, true), true)
      params:
        restored-image: =steps.image*.restored.mfs
        outfile: '{steps.image*.prefix}-MFS-mask.fits'
        threshold: 10.0
        dilate: 2
        boxsize: 60

    source-finder:
      info: automatic source finding
      _use: lib.steps.source-finder.bdsf
      skip: =IF(recipe.selfcal.cal-model-mode=='pybdsm_only', false, IF(recipe.image-enable, IF(recipe.image-aimfast-enable, false, true), true))
      skip_if_outputs: fresh
      params:
        image: =steps.image-*.restored.mfs
        advanced_opts: true
        outfile_gaul: =steps.image-*.prefix + '.gaul'
        outfile_srl: =steps.image-*.prefix + '.srl'

    tigger-convert:
      info: convert model to lsm format
      cab: tigger-convert
      skip: =IF(recipe.selfcal.cal-model-mode=='pybdsm_only', false, IF(recipe.image-enable, IF(recipe.image-aimfast-enable, false, true), true))
      params:
        input-model: =steps.source-finder.outfile_gaul
        output-type: Tigger
        output-model: =STRIPEXT(steps.source-finder.outfile_gaul) + '.lsm.html'

    cross-assess:
      info: image quality assessment
      cab: aimfast
      skip: true
      params:
        residual_image: =steps.image-*.residual.mfs
        outfile: '{steps.image-*.prefix}-im-{info.suffix}.json'

    flagsummary-stats:
      info: report flagging statistics after calibration
      cab: casa.flagsummary
      skip: =IF(recipe.iter==0, false, true)
      params:
        ms: =recipe.ms

    save-flags:
      info: restore flags to a specific version
      cab: casa.flagman
      skip: true
      params:
        ms: =recipe.ms
        versionname: =step.save-flags-0.versionname
        mode: save

    copycol:
      info: Make a copy of the MODEL_DATA column
      skip: true #=not recipe.copy-model-columns
      cab: msutils.copycol
      params:
        msname: =recipe.ms
        fromcol: MODEL_DATA
        tocol: 'MODEL{info.suffix}_DATA'

    upsample:
      info: upsamples model image to higher frequency resolution
      cab: smops
      skip: true
      params:
        ms: =recipe.ms
        input-prefix: =steps.image*.prefix
        output-prefix: "{steps.image*.prefix}-upsampled"
        num-threads: =recipe.ncpu
        polynomial-order: 4
        stokes: =steps.image*.pol
        channels-out: =recipe.upsample-model-channels

    predict:
      _use: lib.steps.wsclean.predict
      skip: true
      params:
        prefix: =IFSET(recipe.upsample-model-channels, steps.upsample-*.output-prefix, steps.image*.prefix)
        nchan: =IFSET(recipe.upsample-model-channels, steps.upsample-*.channels-out, steps.image*.nchan)
        threads: =recipe.ncpu

    predict-copycol:
      info: Make a copy of the MODEL_DATA column
      #skip: =not recipe.copy-model-columns
      skip: true
      cab: msutils.copycol
      params:
        msname: =recipe.ms
        fromcol: MODEL_DATA
        tocol: =IFSET(recipe.upsample-model-channels, 'MODEL{info.suffix}_{recipe.upsample-model-channels}_DATA', 'MODEL{info.suffix}_DATA')

    max-iter:
      info: Maximum number of iterations
      cab: maximum_iter
      params:
        niter: =recipe.selfcal._niters

    time_freq_intervals:
      info: Time and frequency intervals for selfcal
      cab: intervals_out
      params:
        iter: =recipe.iter
        time_intervals: =recipe.selfcal.jones-time
        freq_intervals: =recipe.selfcal.jones-freq
        jones_types: =recipe.selfcal.jones

    selfcal-1:
      info: Round of delay selfcal
      _use: lib.steps.quartical.k
      skip: =IF(recipe.iter==steps.max-iter.max-iter, true, IF(steps.time_freq_intervals.jones_type=='k', IF(recipe.iter==0, true, false), true))
      params:
        #input_model.recipe: =IF(recipe.selfcal.cal-model-mode, steps.output-model, MODEL_DATA)
        #input_model.recipe: =steps.tigger-convert-*.output-model
        input_model.recipe: MODEL_DATA
        output.columns: [CORRECTED_DATA]
        output.gain_directory: "{recipe.dir-out-base}/K-{recipe.iter}.qc/"
        output.log_directory: "{recipe.dir-out-base}/K-{recipe.iter}.qc/log/"
        K.time_interval: =steps.time_freq_intervals.time_int[0]
        K.freq_interval: =steps.time_freq_intervals.freq_int[0]

    selfcal-2:
      info: Round of delay and gain selfcal
      _use: lib.steps.quartical.g
      skip: =IF(recipe.iter==steps.max-iter.max-iter, true, IF(steps.time_freq_intervals.jones_type=='g', IF(recipe.iter==0, true, false), true))
      params:
        input_model.recipe: MODEL_DATA
        output.columns: [CORRECTED_DATA]
        output.gain_directory: "{recipe.dir-out-base}/G-{info.suffix}.qc/"
        output.log_directory: "{recipe.dir-out-base}/G-{info.suffix}.qc/log/"
        G.time_interval: =steps.time_freq_intervals.time_int[0]
        G.freq_interval: =steps.time_freq_intervals.freq_int[0]

    selfcal-3:
      info: Round of delay and gain selfcal
      _use: lib.steps.quartical.k-g
      skip: =IF(recipe.iter==steps.max-iter.max-iter, true, IF(steps.time_freq_intervals.jones_type=='k-g', IF(recipe.iter==0, true, false), true))
      params:
        input_model.recipe: MODEL_DATA
        output.columns: [CORRECTED_DATA]
        output.gain_directory: "{recipe.dir-out-base}/KG-{info.suffix}.qc/"
        output.log_directory: "{recipe.dir-out-base}/KG-{info.suffix}.qc/log/"
        K.time_interval: =steps.time_freq_intervals.time_int[0]
        K.freq_interval: =steps.time_freq_intervals.freq_int[0]
        G.time_interval: =steps.time_freq_intervals.time_int[-1]
        G.freq_interval: =steps.time_freq_intervals.freq_int[-1]