#!/usr/bin/env -S stimela run --last-recipe
_include:
  - caracal-libs.yml

caracal-selfcal:
  name: CARACal selfcal recipe
  info: "Second generation calibration recipe developed for CaraCal"
 
  inputs:
    _include: caracal-schema.yml
    obs:
      info: "Selects observation by label -- edit caracal-observation-sets.yml"
      required: true
    ms:
      dtype: MS
      aliases: ['*.ms']
      required: true
    image-prefix:
      dtype: str
      required: true
    niters:
      info: list of iteration to process, must be selfcal.niter.
      dtype: List[int]
      default: [1]
    image-mfs-image:
      info: Restored mfs image
      dtype: File
    image-mfs-residual:
      info: Residual mfs image
      dtype: File
    image-nchans:
      dtype: int
    image-niter:
      dtype: int
    image-col:
      dtype: str

  for_loop:
    var: iter
    over: niters
    scatter: 1

  steps:
    pa-correction-0: 
      info: invokes cubical to correct for parallactic angle
      skip: =IF(not recipe.selfcal-pa-rotate, IF(recipe.selfcal-enable, false, true), true)
      _use: lib.steps.cubical.pa-corr
      params:
        data.ms: =recipe.ms
        out.column: 'PA_CORRECTED_DATA'
        out.dir: '{root.dir-out-base}/cal-pa.cc0-out'
        dist.ncpu: =recipe.ncpu
        dist.min-chunks: =recipe.ncpu
        model.list: ''
        flags.apply: "-cubical0"
        flags.auto-init: legacy
        flags.save: "cubical0"
        flags.save-legacy: auto
        flags.reinit-bitflags: false
        k.save-to: "{recipe.dir-out-base}/PAsol-{info.suffix}"

    image-pol-0:
      info: image and construct initial model image using the PA_CORRECTED_DATA column using a mask
      skip: =IF(not recipe.selcal-pa-rotate, IF(recipe.image-enable, false, true), true)
      _use: lib.steps.wsclean.image-pol
      params:
        column: =IF(recipe.selfcal.pa-rotate, steps.pa-correction-0.out.column, recipe.image-col)
        no-update-model-required: =recipe.image-no-update-model-required

    quality-assess-0:
      info: image quality assessment
      cab: aimfast
      skip: =IF(not recipe.image-enable, IF(recipe.aimfast-enable, false, true), true)
      params:
        residual_image: =steps.image-*.residual.i.mfs
        outfile: '{steps.image-*.prefix}-im-{info.suffix}.json'

    masking-0:
      info: generate a mask
      cab: breizorro
      skip: =IF(not recipe.image-enable, IF(recipe.image-breizorro-enable, false, true), true)
      params:
        restored-image: =IF(recipe.image-mfs-image, recipe.image-mfs-image, steps.image-0.restored.i.mfs)
        #mask: '{steps.image-0.prefix}-mask.fits'
        mask: '{steps.image-0.prefix}-mask.fits'
        threshold: 10.0
        dilate: 2
        #boxsize: 60

    masking-pol-0:
      info: generate a mask
      cab: breizorro
      skip: =IF(not recipe.image-enable, IF(recipe.image-breizorro-enable, false, true), true)
      params:
        restored-image: =IF(recipe.image-mfs-image, recipe.image-mfs-image, steps.image-pol-0.restored.i.mfs)
        mask: '{steps.image-pol-0.prefix}-mask.fits'
        threshold: 10.0
        dilate: 2
        #boxsize: 60

    image-pol-1:
      info: image and construct initial model image using the CORRECTED_DATA column using a mask
      skip: true
      _use: caracal-selfcal.steps.image-pol-0
      params:
        ms: =recipe.ms
        fits-mask: =IF(recipe.image-fits-mask, recipe.image-fits-mask, IF(recipe.image-breizorro-enable, steps.masking-0.mask, UNSET))
        #fits-mask: =IF(recipe.image-breizorro-enable, steps.masking-0.mask, UNSET)

    source-finder-1:
      info: automatic source finding
      _use: lib.steps.source-finder.bdsf
      params:
        image: =IF(recipe.image-mfs-image, recipe.image-mfs-image, steps.image-*.restored.i.mfs)
        advanced_opts: true
        outfile_gaul: =STRIPEXT(recipe.image-prefix) + '.gaul'
        outfile_srl: =STRIPEXT(recipe.image-prefix) + '.srl'

    tigger-convert-1:
      info: convert model to lsm format
      cab: tigger-convert
      params:
        input-model: =steps.source-finder-*.outfile_gaul
        output-type: Tigger
        output-model: =STRIPEXT(steps.source-finder-*.outfile_gaul) + '.lsm.html'

    quality-assess-1:
      info: image quality assessment
      skip: true
      cab: aimfast
      params:
        residual_image: =IF(recipe.image-mfs-residual, recipe.image-mfs-residual, steps.image-*.residual.i.mfs)
        outfile: '{steps.image-*.prefix}-im-{info.suffix}.json'
 
    selfcal-1:
      info: first round of delay selfcal
      _use: lib.steps.quartical.k
      params:
        #input_model.recipe: =IF(recipe.selfcal.cal-model-mode, steps.output-model, MODEL_DATA)
        input_model.recipe: =steps.tigger-convert-*.output-model
        output.columns: [FSLOPE_CORRECTED_DATA]

    flagsummary-stats-1:
      info: report flagging statistics after calibration
      cab: casa.flagsummary
      params:
        ms: =recipe.ms

    restore-flags-1:
      info: restore flags to a specific version
      cab: casa.flagman
      skip: true
      params:
        ms: =recipe.ms
        versionname: =step.save-flags-0.versionname
        mode: restore

    image-pol-2:
      info: image and construct initial model image using the FSLOPE_CORRECTED_DATA column using a mask
      _use: caracal-selfcal.steps.image-pol-1
      params:
        threshold: 0.000030
        column: FSLOPE_CORRECTED_DATA
        #dd-psf-grid: [2,2]
        #parallel-deconvolution: 4
        #niter: 1000
        #pol: IQ
        #no-update-model-required: true
        #nmiter: 8

    quality-assess-2:
      info: image quality assessment
      cab: aimfast
      params:
              #residual_image: =steps.image-*.residual.i.mfs
        residual_image: =steps.image-2.residual.mfs
        outfile: '{steps.image-*.prefix}-im-{info.suffix}.json'

    masking-2:
      info: generate a mask
      cab: breizorro
      params:
              #restored-image: =steps.image-*.restored.i.mfs
        restored-image: =steps.image-2.restored.mfs
        mask: '{steps.image-2.prefix}-MFS-mask.fits'
        threshold: 15.0
        dilate: 2
        boxsize: 35

    copycol-2:
      info: Make a copy of the MODEL_DATA column
      skip: =not recipe.copy-model-columns
      cab: msutils.copycol
      params:
        msname: =recipe.ms
        fromcol: MODEL_DATA
        #tocol: 'MODEL{info.suffix}_DATA'
        tocol: 'DR1_NOT_HOT_DATA'

    upsample-2:
      info: upsamples model image to higher frequency resolution
      cab: smops
      params:
        ms: =recipe.ms
        input-prefix: =steps.image*.prefix
        output-prefix: "{steps.image*.prefix}-upsampled"
        num-threads: =recipe.ncpu
        polynomial-order: 4
        stokes: =steps.image*.pol
        channels-out: =recipe.upsample-model-channels

    predict-2:
      _use: lib.steps.wsclean.predict-pol
      params:
        prefix: =IF(recipe.upsample-model-channels, steps.upsample-*.output-prefix, steps.image-*.prefix)
        nchan: =IF(recipe.upsample-model-channels, steps.upsample-*.channels-out, steps.image-*.nchan)
        pol: IQUV
        threads: =recipe.ncpu

    predict-copycol-2:
      info: Make a copy of the MODEL_DATA column
      skip: =not recipe.copy-model-columns
      cab: msutils.copycol
      params:
        msname: =recipe.ms
        fromcol: MODEL_DATA
        tocol: =IF(recipe.upsample-model-channels, 'MODEL{info.suffix}_{recipe.upsample-model-channels}_DATA', 'MODEL{info.suffix}_DATA')
 
    selfcal-2:
      info: second round of delay and gain selfcal
      _use: lib.steps.quartical.k-g
      params:
        input_model.recipe: MODEL_DATA
        output.columns: [G_CORRECTED_DATA]
        output.gain_directory: "{recipe.dir-out-base}/KG8-{info.suffix}.qc/"
        output.log_directory: "{recipe.dir-out-base}/KG8-{info.suffix}.qc/log/"

    image-pol-3:
      info: image using the G_CORRECTED_DATA column using a mask
      _use: caracal-selfcal.steps.image-pol-2
      params:
        threshold: 0.000025
        column: G_CORRECTED_DATA
        #no-update-model-required: =recipe.image-no-update-model-required
        #nmiter: 8

    quality-assess-image-3:
      info: image quality assessment
      cab: aimfast
      params:
        residual_image: =steps.image-3.residual.i.mfs
        outfile: '{steps.image-*.prefix}-im-{info.suffix}.json'

    upsample-image-3:
      info: upsamples model image to higher frequency resolution
      cab: smops
      params:
        ms: =recipe.ms
        input-prefix: =steps.image*.prefix
        output-prefix: "{steps.image*.prefix}-upsampled"
        num-threads: =recipe.ncpu
        polynomial-order: 4
        stokes: =steps.image*.pol
        channels-out: =recipe.upsample-model-channels

    predict-upsample-3:
      _use: lib.steps.wsclean.predict-pol
      params:
              #prefix: =IF(recipe.upsample-model-channels, steps.upsample-*.output-prefix, steps.image-*.prefix)
              #nchan: =IF(recipe.upsample-model-channels, steps.upsample-*.channels-out, steps.image-*.nchan)
        prefix: =steps.image-*.prefix
        nchan: =steps.image-*.nchan
        pol: IQUV
        threads: =recipe.ncpu

    copycol-predict-3:
      info: Make a copy of the MODEL_DATA column
      skip: =not recipe.copy-model-columns
      cab: msutils.copycol
      params:
        msname: =recipe.ms
        fromcol: MODEL_DATA
        tocol: =IF(recipe.upsample-model-channels, 'MODEL{info.suffix}_{recipe.upsample-model-channels}_DATA', 'MODEL{info.suffix}_DATA')
