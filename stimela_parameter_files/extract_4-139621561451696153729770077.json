{"binary": "python", "task": "pybdsm", "description": "Source finding in radio images", "parameters": [{"info": "Input image file name", "check_io": true, "name": "filename", "dtype": "file", "required": false, "value": "/home/peter/output/meerkathi-pipeline_4-MFS-image.fits"}, {"info": "Use adaptive rms_box when determining rms and mean maps", "check_io": true, "name": "adaptive_rms_box", "dtype": "bool", "required": false, "value": true}, {"info": "Decompose Gaussian residual image into multiple scales", "check_io": true, "name": "atrous_do", "dtype": "bool", "required": false, "value": false}, {"info": "Perform source extraction on each wavelet scale", "check_io": true, "name": "atrous_bdsm_do", "dtype": "bool", "required": false, "value": false}, {"info": "Max allowed wavelength order, 0 => calculate inside program", "check_io": true, "name": "atrous_jmax", "dtype": "int", "required": false, "value": 0}, {"info": "Low pass filter, either 'b3' or 'tr', for B3 spline or Triangle", "check_io": true, "name": "atrous_lpf", "dtype": "str", "required": false, "value": "b3"}, {"info": "Restrict wavelet Gaussians to islands found in original image", "check_io": true, "name": "atrous_orig_isl", "dtype": "bool", "required": false, "value": false}, {"info": "Fit to the sum of remaining wavelet scales", "check_io": true, "name": "atrous_sum", "dtype": "bool", "required": false, "value": true}, {"info": "Use fast SciPy FFT for convolution", "check_io": true, "name": "use_scipy_fft", "dtype": "bool", "required": false, "value": true}, {"info": "FWHM of restoring beam. Specify as (maj, min, pos ang E of N) in degrees. E.g., beam = (0.06, 0.02, 13.3). None => get from header", "check_io": true, "name": "beam", "dtype": "list:float", "required": false, "value": null}, {"info": "Show options for Gaussian flagging", "check_io": true, "name": "flagging_opts", "dtype": "bool", "required": false, "value": false}, {"info": "Frequency in Hz of input image. E.g., frequency = 74e6. None => get from header.", "check_io": true, "name": "frequency", "dtype": "float", "required": false, "value": null}, {"info": "Background mean map: 'default' => calc whether to use or not, 'zero' => 0, 'const' => clipped mean, 'map' => use 2-D map", "check_io": true, "name": "mean_map", "dtype": "str", "required": false, "value": "default"}, {"info": "If True and beam_spectrum is None, then assume header beam is for median frequency and scales with frequency for channels", "check_io": true, "name": "beam_sp_derive", "dtype": "bool", "required": false, "value": false}, {"info": "Get beams for each channel in FITS header. Eg. BMAJ1, BMAJ1, BPA1; BMAJ2, BMIN2, BPA2", "check_io": true, "name": "multi_chan_beam", "dtype": "bool", "required": false, "value": false}, {"info": "FWHM of synthesized beam per channel. Specify as [(bmaj_ch1, bmin_ch1, bpa_ch1), (bmaj_ch2, bmin_ch2, bpa_ch2), etc.] in degrees. E.g., beam_spectrum = [(0.01, 0.01, 45.0), (0.02,0.01, 34.0)] for two channels. None => all equal to beam", "check_io": true, "name": "beam_spectrum", "dtype": "list:list", "required": false, "value": null}, {"info": "List of channels to average if collapse_mode = 'average', starting from 0. E.g., collapse_av = [0, 1, 5]. [] => all", "check_io": true, "name": "collapse_av", "dtype": "list:int", "required": false, "value": null}, {"info": "Number of the channel for source extraction, if collapse_mode = 'single', starting from 0", "check_io": true, "name": "collapse_ch0", "dtype": "int", "required": false, "value": 0}, {"info": "Collapse method: 'average' or 'single'. Average channels or take single channel to perform source detection on", "check_io": true, "name": "collapse_mode", "dtype": "str", "required": false, "value": "average"}, {"info": "Frequency in Hz of channels in input image when more than one channel is present. E.g., frequency_sp = [74e6, 153e6]. None => get from header", "check_io": true, "name": "frequency_sp", "dtype": "list:float", "required": false, "value": null}, {"info": "Box size, step size for rms/mean map calculation. Specify as (box, step) in pixels. E.g., rms_box = (40, 10) => box of 40x40 pixels, step of 10 pixels. None => calculate inside program", "check_io": true, "name": "rms_box", "dtype": "list:int", "required": false, "value": null}, {"info": "Background rms map: True => use 2-D rms map; False => use constant rms; None => calculate inside program", "check_io": true, "name": "rms_map", "dtype": "bool", "required": false, "value": null}, {"info": "Type of thresholding: None => calculate inside program, 'fdr' => use false detection rate algorithm, 'hard' => use sigma clipping", "check_io": true, "name": "thresh", "dtype": "str", "required": false, "value": null}, {"info": "Threshold for the island boundary in number of sigma above the mean. Determines extent of island used for fitting", "check_io": true, "name": "thresh_isl", "dtype": "float", "required": false, "value": 12}, {"info": "Source detection threshold: threshold for the island peak in number of sigma above the mean. If false detection rate thresholding is used, this value is ignored and thresh_pix is calculated inside the program", "check_io": true, "name": "thresh_pix", "dtype": "float", "required": false, "value": 14}, {"info": "Radius of aperture in pixels inside which aperture fluxes are measured for each source. None => no aperture fluxes measured", "check_io": true, "name": "aperture", "dtype": "bool", "required": false, "value": null}, {"info": "Position the aperture (if aperture is not None) on: 'centroid' or 'peak' of the source.", "check_io": true, "name": "aperture_posn", "dtype": "str", "required": false, "value": "centroid"}, {"info": "Limit in Jy/beam below which pixels are blanked. None => no such blanking is done", "check_io": true, "name": "blank_limit", "dtype": "float", "required": false, "value": null}, {"info": "Theoretical estimate of number of beams per source. None => calculate inside program", "check_io": true, "name": "bmpersrc_th", "dtype": "float", "required": false, "value": null}, {"info": "Check for pixels outside the universe", "check_io": true, "name": "check_outsideuniv", "dtype": "bool", "required": false, "value": false}, {"info": "Detection image file name used only for detecting islands of emission. Source measurement is still done on the main image", "check_io": true, "name": "detection_image", "dtype": "file", "required": false, "value": null}, {"info": "Cache internally derived images to disk", "check_io": true, "name": "do_cache", "dtype": "bool", "required": false, "value": false}, {"info": "stimate uncertainties for 'M'-type sources using Monte Carlo method", "check_io": true, "name": "do_mc_errors", "dtype": "bool", "required": false, "value": false}, {"info": "Alpha for FDR algorithm for thresholds", "check_io": true, "name": "fdr_alpha", "dtype": "float", "required": false, "value": 0.05}, {"info": "For thresh = None; if #false_pix / #source_pix < fdr_ratio, thresh = 'hard' else thresh = 'fdr'", "check_io": true, "name": "fdr_ratio", "dtype": "float", "required": false, "value": 0.1}, {"info": "Sigma for clipping Gaussians while creating fitted image", "check_io": true, "name": "fittedimage_clip", "dtype": "float", "required": false, "value": 0.1}, {"info": "Fix major and minor axes and PA of Gaussians to beam?", "check_io": true, "name": "fix_to_beam", "dtype": "bool", "required": false, "value": true}, {"info": "Group all Gaussians in each island into a single source", "check_io": true, "name": "group_by_isl", "dtype": "bool", "required": false, "value": false}, {"info": "Group Gaussians into sources using 'intensity' map or 'curvature' map", "check_io": true, "name": "group_method", "dtype": "str", "required": false, "value": "intensity"}, {"info": "Tolerance for grouping of Gaussians into sources: larger values will result in larger sources", "check_io": true, "name": "group_tol", "dtype": "float", "required": false, "value": 1.0}, {"info": "Initial guess for Gaussian parameters: 'default', 'simple', or 'nobeam'", "check_io": true, "name": "ini_gausfit", "dtype": "str", "required": false, "value": "default"}, {"info": "Method by which inital guess for fitting of Gaussians is chosen: 'intensity' or 'curvature'", "check_io": true, "name": "ini_method", "dtype": "str", "required": false, "value": "intensity"}, {"info": "Kappa for clipped mean and rms. None => calculate inside program", "check_io": true, "name": "kappa_clip", "dtype": "float", "required": false, "value": null}, {"info": "Minimum number of pixels with emission per island (minimum is 6 pixels). None -> calculate inside program", "check_io": true, "name": "minpix_isl", "dtype": "int", "required": false, "value": null}, {"info": "Number of cores to use during fitting, None => use all", "check_io": true, "name": "ncores", "dtype": "int", "required": false, "value": null}, {"info": "Find and fit peaks of large islands iteratively", "check_io": true, "name": "peak_fit", "dtype": "bool", "required": false, "value": true}, {"info": "If island size in beam area is more than this, attempt to fit peaks iteratively (if peak_fit = True). Min value is 30", "check_io": true, "name": "peak_maxsize", "dtype": "float", "required": false, "value": 30.0}, {"info": "Value of constant rms in Jy/beam to use if rms_map = False. None => calculate inside program", "check_io": true, "name": "rms_value", "dtype": "float", "required": false, "value": null}, {"info": "Rank of the interpolating function for rms/mean map", "check_io": true, "name": "spline_rank", "dtype": "int", "required": false, "value": 3}, {"info": "Split island if it is too large, has a large convex deficiency and it opens well.", "check_io": true, "name": "split_isl", "dtype": "bool", "required": false, "value": true}, {"info": "If island size in beam area is more than this, consider splitting island. Min value is 50", "check_io": true, "name": "splitisl_maxsize", "dtype": "float", "required": false, "value": 50.0}, {"info": "List of source positions at which fitting is done.  E.g., src_ra_dec = [(197.1932, 47.9188), (196.5573, 42.4852)]", "check_io": true, "name": "src_ra_dec", "dtype": "list:list", "required": false, "value": null}, {"info": "Radius of the island (if src_ra_dec is not None) in pixels. None => radius is set to the FWHM of the beam major axis.", "check_io": true, "name": "src_radius_pix", "dtype": "int", "required": false, "value": null}, {"info": "Stops after: 'isl' = island finding step or 'read' = image reading step", "check_io": true, "name": "stop_at", "dtype": "str", "required": false, "value": null}, {"info": "Do source detection on only a part of the image. Specify as (xmin, xmax, ymin, ymax) in pixels. E.g., trim_box = (120, 840, 15, 895). None => use entire image", "check_io": true, "name": "trim_box", "dtype": "list:int", "required": false, "value": null}, {"info": "Output file name. None => file is named automatically; 'SAMP' => send to SAMP hub (e.g., to TOPCAT, ds9, or Aladin)", "check_io": true, "name": "outfile", "dtype": "file", "required": true, "value": "/home/peter/output/meerkathi-pipeline_4-pybdsm.fits"}, {"info": "BBS format, type of patch to use: None => no patches. 'single' => all Gaussians in one patch. 'gaussian' => each Gaussian gets its own patch. 'source' => all Gaussians belonging to a single source are grouped into one patch. 'mask' => use mask file specified by bbs_patches_mask", "check_io": true, "name": "bbs_patches", "dtype": "str", "required": false, "value": null}, {"info": "Name of the mask file (of same size as input image) that defines the patches if bbs_patches = 'mask'", "check_io": true, "name": "bbs_patches_mask", "dtype": "file", "required": false, "value": null}, {"info": "Type of catalog to write:  'gaul' - Gaussian list, 'srl' - source list (formed by grouping Gaussians), 'shap' - shapelet list (FITS format only)", "check_io": true, "name": "catalog_type", "dtype": "str", "required": false, "value": "gaul"}, {"info": "Overwrite existing file?", "check_io": true, "name": "clobber", "dtype": "bool", "required": false, "value": true}, {"info": "Correct source parameters for image projection (BBS format only)?", "check_io": true, "name": "correct_proj", "dtype": "bool", "required": false, "value": true}, {"info": "Format of output catalog", "check_io": true, "name": "format", "dtype": "str", "required": false, "value": "fits"}, {"info": "Include flux densities from each channel (if any)?", "check_io": true, "name": "incl_chan", "dtype": "bool", "required": false, "value": false}, {"info": "Include islands without any valid Gaussians (source list only)?", "check_io": true, "name": "incl_empty", "dtype": "bool", "required": false, "value": false}, {"info": "Name for entries in the output catalog (BBS format only). None => use image file name", "check_io": true, "name": "srcroot", "dtype": "file", "required": false, "value": null}, {"info": "Convert output model to tigger format", "check_io": true, "name": "port2tigger", "dtype": "bool", "required": false, "value": true}, {"info": "Calculate spectral indices (for multi-channel image)", "check_io": true, "name": "spectralindex_do", "dtype": "bool", "required": false, "value": false}, {"info": "Start frequency (unit => Hz)", "check_io": true, "name": "freq0", "dtype": "float", "required": false, "value": null}], "prefix": " ", "tag": "1.0.0", "msdir": false, "base": "stimela/lofar"}